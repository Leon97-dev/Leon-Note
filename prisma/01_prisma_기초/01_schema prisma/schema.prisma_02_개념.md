# Prisma Schema 기본 개념

## 기본 타입 (Scalar Types)

**< PostgreSQL 기준 >**

- `String (문자열)`
  \_ 대응되는 DB 타입: TEXT, VARCHAR
- `Int (정수형)`
  \_ 대응되는 DB 타입: INTEGER, SERIAL
- `BigInt (매우 큰 정수)`
  \_ 대응되는 DB 타입: BIGINT
- `Float (부동소수점 숫자)`
  \_ 대응되는 DB 타입: DOUBLE PRECISION
- `Decimal (고정 소수점, 정밀 계산용)`
  \_ 대응되는 DB 타입: NUMERIC, DECIMAL
- `Boolean (true/false)`
  \_ 대응되는 DB 타입: BOOLEAN
- `DateTime (날짜와 시간)`
  \_ 대응되는 DB 타입: TIMESTAMP, DATE
- `Json (JSON 데이터)`
  \_ 대응되는 DB 타입: JSON, JSONB

_======================================================================================_

## 어노테이션 (Annotations)

어노테이션은 필드 뒤에 붙는 메타정보다.
이건 DB 제약조건, 기본값, 관계, 인덱스 같은 걸 정의할 때 사용한다.

**< 식별자 관련 >**

- `@id` → 기본키(primary key)
- `@unique` → 중복 불가(unique key)
- `@default()` → 기본값 설정
  \_숫자: `@default(0)`
  \_문자열: `@default("Guest")`
  \_날짜: `@default(now())`
  \_uuid: `@default(uuid())`
- `@updatedAt` → 레코드 수정 시 자동 갱신
- `@map("column_name")` → DB 컬럼명 강제 지정

**< 관계(Relation) >**

```prisma
@relation(fields: [userId], references: [id])
```

→ 외래키(Foreign key) 관계 명시
관계 이름을 지정하려면 `@relation("RelationName")`

**< 기타 >**

- `@@index([field])` → 인덱스 생성
- `@@unique([field1, field2])` → 복합 고유 제약
- `@@map("table_name")` → DB 테이블 이름 변경
- `@db.VarChar(50)` → DB 고유 타입 명시 (DB 커스텀 제어용)

_======================================================================================_

## onDelete 유형

"부모 레코드를 지울 때, 이 FK(외래키)로 연결된 자식 레코드를 어떻게 처리할까?”를 미리 정해두는 규칙

- `Cascade`: 연쇄 삭제
  \_ 동작(부모 삭제시): 자식도 자동 삭제
  \_ 자식 FK 필수 여부: 상관없음
  \_ 요약: “부모 없으면 자식도 없앤다”
- `SetNull`: NULL로 설정
  \_ 동작(부모 삭제시): 자식의 FK를 NULL로 바꿈
  \_ 자식 FK 필수 여부: 자식 FK가 nullable이어야 함
  \_ 요약: “부모 없어도 자식은 남겨둔다”
- `Restrict`: 제한
  \_ 동작(부모 삭제시): 부모 삭제 거부 (자식이 있으면 에러)
  \_ 자식 FK 필수 여부: 상관없음
  \_ 요약: “기록 보호: 자식 있으면 부모 못 지움”
- `NoAction`: 아무 액션 X
  \_ 동작(부모 삭제시): DB가 추후 제약 검사로 막을 수 있음 (현실적으로 Restrict에 가까움)
  \_ 자식 FK 필수 여부: 자식 FK가 nullable이어야 함
  \_ 요약: “특별히 지정 안 함”에 가까움
- `SetDefault`: 기본값으로
  \_ 동작(부모 삭제시): 자식 FK를 기본값으로 바꿈
  \_ 자식 FK 필수 여부: 기본값 필요
  \_ 요약: “특정 기본 부모로 돌려놓기” (잘 안 씀)

**< 언제 어디에 쓰면 좋은가? >**

- `Cascade`
  \_ 상황: 유저가 삭제되면 그 유저의 환경설정도 의미 없으니 같이 삭제할 때
  \_ ✅ 장점: 데이터 깨끗, 고아 레코드 없음
  \_ ⚠️ 주의: 실수로 부모를 지우면 하위가 싹 지워질 수 있음
- `SetNull`
  \_ 상황: 유저가 탈퇴해도 주문 기록은 남겨야 하는 서비스가 있을 때
  \_ ✅ 장점: 과거 기록 보존(분석/정산/증빙)
  \_ ⚠️ 주의: FK는 nullable(옵셔널) 필수
- `Restrict `
  \_ 상황: 상품이 이미 주문에 쓰였다면, 상품 삭제 금지가 안전할 때, 재무/법무상 보존이 필요한 데이터에 흔함
  \_ ✅ 장점: 중요한 이력 파괴 방지
  \_ ⚠️ 주의: 부모를 지우려면 먼저 모든 자식 정리 필요 → 운영 툴에서 가드 로직 필요

**< 자주 발생하는 5가지 오류와 주의점 >**
1️⃣ SetNull인데 FK가 필수일 때
외래키 필드가 nullable(?)이 아닌데 onDelete: SetNull을 쓰면 마이그레이션 에러 발생

2️⃣ Cascade로 인한 대량 삭제 사고
관리자 툴에서는 삭제 전 확인 모달 또는 권한 체크 가드를 꼭 추가해야 안전하다.
“소프트 삭제(soft delete)”(isDeleted 필드)로 대체하는 게 안전함

3️⃣ Restrict 때문에 삭제가 막힐 때
동작 자체는 의도적이지만, UX 상 명확한 안내 메시지가 필수다.
\_ 예시: `"이 항목은 연결된 데이터(3건) 때문에 삭제할 수 없습니다."`
API 레벨에서도 적절한 409(CONFLICT) 응답을 고려

4️⃣ 순환 참조 (서로 Cascade)
A → B 가 Cascade, B → A 도 Cascade인 경우는 삭제 시 순환 트리거로 인해 DB가 동작 불가
그래서 방향을 명확히 정해야 한다. 한쪽만 Cascade, 다른 한쪽은 Restrict 또는 SetNull

5️⃣ 데이터 정리 정책 부재
탈퇴, 상품 삭제 등은 단순한 DB 문제를 넘어 법적·정책적 영역
\_ 예시: 탈퇴는 개인정보는 익명화 → SetNull, 게시글은 완전 삭제 가능 → Cascade
`결정은 법무/정책팀과 합의 후 문서화해야 한다.`

_======================================================================================_

## 실무 자주 사용하는 enum status 값

- `PENDING`: 결제 대기, 승인 대기
- `PROCESSING`: 결제 완료 후 배송 준비
- `SHIPPED`: 배송 중
- `COMPLETE`: 배송 완료
- `CANCELLED`: 주문 취소

_======================================================================================_
