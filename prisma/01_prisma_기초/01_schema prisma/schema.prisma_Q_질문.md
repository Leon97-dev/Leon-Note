# 1. @id Int vs String 쓰는 기준이 뭘까?

결론: 실무에서는 Int를 더 자주 쓴다.

**< autoincrement() >**

- 값 형태: 1, 2, 3, 4, 5...
- DB가 자동 증가시킴: ✅
- 눈으로 보기 쉬움: ✅
- 중복될 확률: 거의 없음 (DB 내부에서 관리)
- 크기: 작음 (4byte)
- 정렬, 인덱싱 성능: 빠름
- 보안/추적 어려움: 낮음
- 싱황: 내부용/단일 서버

**< uuid() >**

- 값 형태: 랜덤한 고유 문자열
- DB가 자동 증가시킴: ❌ (Prisma가 생성함)
- 눈으로 보기 쉬움: ❌
- 중복될 확률: 사실상 0 (랜덤 128비트)
- 크기: 큼 (36문자 문자열)
- 정렬, 인덱싱 성능: 느림
- 보안/추적 어려움: 높음
- 싱황: 외부 API/분산 서버

_======================================================================================_

# 2. N:M(다대다) 관계일 때 자동으로 중간 조인 테이블이 만들어질까?

1️⃣ N:M 관계는 사실 직접 연결이 불가능하다.
데이터베이스는 기본적으로
\_ 1:1 → 외래키(FK) 하나로 연결 가능
\_ 1:N → 자식 테이블에 FK 두면 해결
\_ N:M(다대다) → 직접 연결이 불가능

이유는 하나의 User가 여러 Product를 찜하고, 하나의 Product를 여러 User가 찜할 수 있기 때문이다.
**즉, 양쪽이 모두 “여러 개”를 가져서 FK 한쪽만 두면 모순이 발생한다.**

2️⃣ 그래서 DB에서는 항상 “중간 테이블”이 필요하다.
중간 테이블이 있어야만 “누가 어떤 상품을 찜했는가”를 저장할 수 있다.

```bash
User 테이블
-------------------
id | name
1  | Alice
2  | Bob

Product 테이블
-------------------
id | name
1  | Apple
2  | Banana

user_saved_products 테이블 (자동 생성)
--------------------------------------
userId | productId
1      | 1
1      | 2
2      | 1
```

3️⃣ Prisma가 자동으로 중간 테이블을 만들 수 있다.
다대다 관계를 보고 판단해 자동으로 만들어준다.
예를 들어 User, Product 두 테이블이 다대다 관계면
\_ UserToProduct 이런 식으로 만들어진다.
물론, 직접 만들 수 있고 (명시적 조인 테이블) Prisma는 이미 있다고 판단해 그대로 사용한다.
직접 만드는 이유는 추가 정보가 필요 할 때 넣어줘야 하기 때문이다.

_======================================================================================_

# 3. Float vs Demical 실제로 자주 쓰이는 건?

결론: 실제 서비스에서는 Demical을 자주 쓴다.

1️⃣ Float (부동소수점)
컴퓨터 내부에서는 2진수(0,1)로 저장하기 떄문에, 미세한 오차가 있다.

✅ 장점
\_ 계산 빠름
\_ 메모리 적게 차지
\_ 대략적인 통계, 평균값 등에 적합

❌ 단점
\_ 금액 계산에 치명적 오차 가능 (예: 1000원 + 0.1원이 1000.099999... 로 저장됨)
\_ 반올림이나 세금 계산 시 오류 누적

2️⃣ Decimal (고정소수점)
`price Decimal @db.Decimal(10,2)`
\_ “고정된 자릿수” 그대로 저장함.
\_ 10,2는 → 전체 10자리 중 소수점 2자리 (예: 99999999.99 까지 저장 가능)

✅ 장점
\_ 오차 없음 (정확한 금액 계산 가능)
\_ 반올림/세금 계산이 정확
\_ DB 차원에서 금액을 안전하게 처리

❌ 단점
\_ 계산속도 느림
\_ 약간 더 많은 저장공간 사용

_======================================================================================_

# 4. 왜 UserPreference가 1:1 관계 일까? 유저가 여러 preference를 가지는 경우는?

스키마 구조 상 `userId @unique`
\_ 한 유저당 딱 하나의 UserPreference만 존재
\_ 즉, 1:1 관계(one-to-one)가 되기 때문에 1:1 관계인 것이다.

UserPreference라는 단어의 본질은 각 유저 환경설정, 알림 여부, 언어, 테마 등 다양한 것은 맞다.
근데 여기 스키마 구조는 이메일 수신을 수락/거절로 보기 때문에 유저당 한 세트의 설정이 자연스럽다.
**물론, 서비스에 따라 1:N 관계가 될 수 있다.**
**그럴 땐 UserPreference를 분류형 데이터로 세분화하면 된다.**

```prisma
model User {
  id             String          @id @default(uuid())
  preferences    UserPreference[] // 여러 선호 가능
}

model UserPreference {
  id       String   @id @default(uuid())
  category String   // 예: "SPORTS", "BEAUTY"
  strength Int      // 선호 강도 (0~100)
  userId   String
  user     User     @relation(fields: [userId], references: [id])
}
```

이러면 “한 유저가 여러 선호 항목을 가진다”로 바뀌어 1:N 관계다.
결국 이름에 따라 설계가 달라진다.
\_ `UserPreference`: 유저의 설정값 세트 > 1:1
\_ `UserLikes/UserCategoryPreference`: 유저가 좋아하는 여러 항목 > 1:N
\_ `UserSavedProducts`: 유저가 저장한 여러 상품 > N:M

**즉, “Preference”가 설정(Setting)인지, 목록(List)인지에 따라 다르다.**

_======================================================================================_

# 5. unitprice와 price 차이

상품 테이블(Product)의 price는 현재 가격
주문 아이템(OrderItem)의 unitPrice는 구매 당시 가격

1️⃣ 이유 (왜 이렇게 하는가?)

- `회계 및 세금 처리`
  \_ 결제 시점의 금액이 **영수증, 세금계산서, 회계 기록**으로 확정된다.
  \_ 나중에 할인돼도 “그 당시엔 5만원이었음”이 법적 근거다.
  \_ 그래서 **결제 시점의 가격을 따로 저장**해야 한다.

- `분석 및 리포트`
  \_ “이 고객은 언제, 얼마에 샀는가”를 정확히 알기 위해서다.
  \_ 나중에 “그때는 비쌌는데 지금은 싸네” 같은 데이터 분석 가능하다.

- `상품 가격은 계속 변하니까`
  \_ 세일, 프로모션, 환율 변화 등으로 `Product.price`는 수시로 바뀐다.
  \_ `OrderItem.unitPrice`를 별도로 저장하면, 나중에 Product가 업데이트되어도 주문 이력은 그대로 남는다.

2️⃣ 반대로 unitPrice 없이 Product만 참조하면?
그럼 주문 내역을 볼 때마다 Product 테이블에서 price를 불러오는데,
Product 가격이 50,000 → 40,000으로 바뀌면, 과거 주문도 전부 40,000으로 표시된다.
**즉, 이력 왜곡 발생이 발생한다.**

_======================================================================================_

# 6. @ vs @@ 의 차이

`@` → **단일 필드**에 붙는 속성
`@@` → **모델 전체(테이블 레벨)** 에 붙는 속성

- `@@unique([...])`: 여러 필드의 조합이 유일해야 한다
- `@@index([...])`: 여러 필드에 인덱스 생성 (검색 최적화용)

1️⃣ `@@unique([orderId, productId])`의 의미
“orderId + productId 조합은 테이블 안에서 절대 중복되면 안 된다.”
**즉, 하나의 주문(Order) 안에 같은 상품(Product)이 두 번 들어가면 안 된다.**
DB가 “이 조합은 이미 존재함” 하고 막아준다.

2️⃣ 왜 배열로 감싸나?
Prisma에서 @@unique()는 복합(unique) 제약조건이다.
**즉, 두 개 이상의 필드를 묶어서 하나의 유일키 로 설정할 때 그 필드들을 배열로 써야 한다.**
이걸 **복합 유니크 키**라고 부른다.

3️⃣ 실무에서 왜 중요하냐? (데이터 무결성 유지 ✅)

- 예시
  \_ 한 주문(Order)에 “상품 A”를 이미 담았는데,
  \_ 또다시 “상품 A”를 넣는 API 요청이 오면?

이 때 DB가 자동으로 막아준다. → “Unique constraint failed”.
**즉, 코드 레벨에서 중복 체크를 따로 안 해도, DB 차원에서 중복 삽입을 방어한다.**

4️⃣ 만약 똑같은 상품을 또 구매하려고 수량을 추가할 때는 위배가 되냐?
위배가 된다는 말은, 즉 똑같은 코드가 반복되었다는 뜻이다.

_======================================================================================_
