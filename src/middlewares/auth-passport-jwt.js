// TODO) Auth: 요청마다 실행되는 커스텀 로직
// ?) passport에 등록된 'jwt' 전략을 실행하여 로그인 여부를 판별하는 인증 미들웨어 (passport-jwt 방식)
// ?) 성공 시 req.user에 사용자 정보를 주입하고, 실패 시 JSON 에러로 응답한다.
// &) Library Import
import passport from 'passport';

export const requireAuth = (req, res, next) => {
  passport.authenticate(
    'jwt',
    {
      session: false, // 세션 기반 인증을 쓰지 않음 (JWT는 무상태)
      failWithError: true, // 실패 시 next(err)로 전달해 커스텀 응답 가능
    },
    (err, user, info) => {
      if (err) return next(err);

      // *) user가 없다 = JWT가 만료됨 / 서명 위조 / 토큰 없음
      if (!user) {
        return res.status(401).json({
          success: false,
          message: info?.message || '인증에 실패했습니다',
          error: 'UNAUTHORIZED',
        });
      }

      // *) 전략 검증이 통과하면, req.user에 주입해 이후 미들웨어/컨트롤러에서 사용
      req.user = user;

      next();
    }
  )(req, res, next);
};

/**
 * ------------------------------------------------------------
 * &) 왜 passport 기반 requireAuth 미들웨어가 필요한가?
 * ------------------------------------------------------------
 * JWT 검증 로직을 직접 미들웨어 안에 하드코딩하지 않고,
 * passport 전략(JWT Strategy)에 인증 책임을 완전히 위임하는 방식이다.
 *
 * 이 구조는 인증 방식을 독립된 전략으로 관리할 수 있어
 * 유지보수성과 확장성이 매우 뛰어나다.
 *
 * 예: JWT → OAuth(구글/카카오) → 세션 기반 로그인 등
 * 인증 방식이 바뀌어도 requireAuth는 변하지 않는다.
 *
 * ------------------------------------------------------------
 * &) 처리 흐름 요약
 * ------------------------------------------------------------
 * 1) passport.authenticate('jwt') 실행
 *    - 등록된 JWT Strategy가 토큰 검증 수행
 *
 * 2) 검증 성공 → user 객체 반환
 *    → req.user에 주입 후 next()
 *
 * 3) 검증 실패 → user = false
 *    → 401 Unauthorized JSON 응답
 *
 * 4) 검증 중 오류 발생
 *    → next(err)로 글로벌 에러 핸들러로 전달
 *
 * ------------------------------------------------------------
 * &) 어떤 API에 적용해야 하는가?
 * ------------------------------------------------------------
 * ✔ 프로필 조회/수정
 * ✔ 게시글/댓글 생성·수정·삭제
 * ✔ 장바구니, 주문, 결제
 * ✔ 관리자/판매자 전용 API (requireRole과 함께 사용)
 *
 * 단순한 공개 조회 API에는 적용하지 않는다.
 *
 * ------------------------------------------------------------
 * &) 왜 Router 레벨에서 사용하는가?
 * ------------------------------------------------------------
 * 인증은 “요청 전체를 검사하는 레이어”이기 때문에
 * 컨트롤러보다 먼저 실행되어야 한다.
 *
 * 예)
 *   router.post('/articles', requireAuth, asyncHandler(create));
 *
 * 이렇게 하면 컨트롤러에서는 req.user가 항상 존재하므로
 * 인증 체크 로직을 넣지 않아도 된다.
 *
 * ------------------------------------------------------------
 * &) 장점 요약
 * ------------------------------------------------------------
 * ✔ 인증 로직이 컨트롤러에서 제거됨 → 코드가 깔끔해짐
 * ✔ 전략 기반 구조 → OAuth 등 다양한 인증 추가가 쉬움
 * ✔ 테스트 코드 작성이 매우 용이
 * ✔ 실무에서 가장 널리 쓰는 방식 중 하나
 *
 * ------------------------------------------------------------
 * &) 결론
 * ------------------------------------------------------------
 * passport-jwt 기반 requireAuth는
 * “확장성 있고 실무 친화적인 인증 미들웨어”로서 매우 적절한 구조이며,
 * 프로젝트가 커질수록 이 구조의 장점이 더욱 크게 드러난다.
 */
